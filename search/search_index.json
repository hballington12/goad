{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to GOAD","text":"<p>Geometric Optics with Aperture Diffraction (GOAD) is a code for simulating light scattering from large particles. It approximates the near-field scattering for an incident plane wave for large particles, and then uses aperture diffraction theory to map the near-field to the far-field. It computes the Mueller matrix and integrated optical scattering parameters. The core is written in Rust, with bindings to Python.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>To get started with an orientation averaging problem, see the <code>Convergence</code> class, which is the recommended way to run GOAD. Then head over to <code>Settings</code> for more config options, and then to <code>Results</code> for more information on the output.</p>"},{"location":"#when-is-goad-applicable","title":"When is GOAD applicable?","text":"<p>You can usually use GOAD when the following conditions are met:</p> <ul> <li>The overall particle size <code>d</code> is much larger than the wavelength <code>\u03bb</code>.</li> <li>The field of interest is in the far-field zone, ie. at a distance <code>r</code> where <code>r &gt;&gt; \u03bb</code> and <code>r &gt;&gt; d</code>.</li> </ul>"},{"location":"#example","title":"Example","text":"Python Rust <pre><code>from goad import MultiProblem, Settings\n\n# Setup and run a multi-orientation problem with default settings\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n</code></pre> <pre><code>fn main() {\n    use goad::multiproblem::MultiProblem;\n    use goad::settings;\n\n    // Setup and run a multi-orientation problem with default settings\n    let mut multiproblem = MultiProblem::new(None, settings::load_config().ok()).unwrap();\n    multiproblem.solve();\n}\n</code></pre>"},{"location":"#contents","title":"Contents","text":""},{"location":"#user-guide","title":"User Guide","text":"<ul> <li>Settings</li> <li>Results</li> <li>Checks</li> <li>Convergence</li> </ul>"},{"location":"checks/","title":"Checks","text":"<p>There are a few ways to check that the results from a GOAD solve are valid. Or rather, there are a few ways to measure the quality of results in a best case scenario, since GOAD itself is an approximate method.</p>"},{"location":"checks/#prerequisite","title":"Prerequisite","text":"<p>GOAD is only valid in the geometric optics regime, which is when the wavelength is much smaller than the size of the geometry. The size parameter <code>X</code> is defined as <code>d\u03c0/\u03bb</code>, where <code>d</code> is (loosely) defined as the maximum dimension of the geometry and <code>\u03bb</code> is the wavelength. GOAD is only valid for <code>X &gt; 20</code>, with an accuracy that increases  with <code>X</code>.</p>"},{"location":"checks/#energy-conservation","title":"Energy Conservation","text":"<p>Your first check should be to ensure a reasonable input to output energy conservation. You can do this by inspecting the powers in a goad Results object. Anything under 95% conservation usually indicates some issue with the solve. Possible causes include:</p> <ul> <li>The beam thresholds are poorly set, or the cutoff power is too low. Generally you can inspect each component of the powers object to determine how much of the input power is lost to each truncation criteria. </li> <li>The recursion limits are too low. Generally you will need at least 5 maximum recursions and total internal reflections. The recommended values are 10 each, but you may need to increase to 20 or more in some cases.</li> <li>The geometry contains extremely small faces compared to the overall geometry size. This can sometimes lead to issues with the beam clipping algorithm. A reasonable rule-of-thumb is to ensure that the smallest face has an area no less than 1% of the largest face area.</li> </ul>"},{"location":"checks/#binning-resolution","title":"Binning Resolution","text":"<p>The second check is usually to ensure that the binning resolution (especially in theta) is fine enough to resolve the forward scattering peak. In the geometric optics regime, in which GOAD is valid, the width of the forward scattering peak in radians is approximately <code>\u03bb/d</code>. Therefore if you are computing the field starting from theta = 0\u00b0, there should be at least 3 bins until <code>\u03bb/d</code>, otherwise the asymmetry parameter and scattering cross sections will be inaccurately computed. As an example:</p>  Python <pre><code>from goad import BinningScheme, MultiProblem, Settings\n\ngeom_path = \"hex.obj\"\nwavelength = 0.532\n# hex.obj is a column with length 10 and radius 5\n# wavelength is 0.532, so we expect the forward scattering peak to\n# have width in degrees \u2248 0.532/10 * 180/\u03c0 = 3\u00b0\n# A reasonable binning scheme would have at least 3 bins to cover this range\n# ie. 180 theta bins (from 0\u00b0 to 180\u00b0)\nbinning = BinningScheme.simple(num_theta=180, num_phi=60)\nsettings = Settings(\n    geom_path=geom_path, wavelength=wavelength, binning=binning, seed=42\n)\nmp = MultiProblem(settings)\nmp.solve()\nprint(f\"Asymmetry: {mp.results.asymmetry}\")  # prints: \"0.8129\"\n\n# Example of what not to do: Only 1 bin to cover the forward scattering peak:\nbinning = BinningScheme.simple(num_theta=60, num_phi=60)\nsettings = Settings(\n    geom_path=geom_path, wavelength=wavelength, binning=binning, seed=42\n)\nmp = MultiProblem(settings)\nmp.solve()\nprint(f\"Asymmetry: {mp.results.asymmetry}\")  # prints: \"0.8531\" (5% error)\n\n# Check that 1 degree binning is sufficient by increasing the resolution without\n# significant change in asymmetry:\nbinning = BinningScheme.simple(num_theta=360, num_phi=60)\nsettings = Settings(\n    geom_path=geom_path, wavelength=wavelength, binning=binning, seed=42\n)\nmp = MultiProblem(settings)\nmp.solve()\nprint(f\"Asymmetry: {mp.results.asymmetry}\")  # prints: \"0.8108\"\n</code></pre>"},{"location":"checks/#number-of-orientations","title":"Number of Orientations","text":"<p>When running an orientation averaging problem, there is no easy way to know beforehand how many orientations are needed to converge. As a general rule, the number of required orientations:</p> <ul> <li>Increases with the particle size</li> <li>Decreases with particle complexity</li> <li>Decreases with number of particles in the ensemble (if using an ensemble)</li> <li>Decreases with wavelength</li> </ul> <p>In the geometric optics regime where GOAD operates, you typically need somewhere in the range of 1000 to 10000 orientations to converge on the integrated scattering parameters to within 1% error, which is the point at which the real error from GOAD vs. a numerically exact solution like the DDA becomes the leading error term. The recommended way to run an orientation averaging problem where you don't need to specify the number of orientations beforehand is via a GOAD Convergence.</p>"},{"location":"convergence/","title":"Convergence","text":""},{"location":"convergence/#basic-usage","title":"Basic Usage","text":"<p>When computing orientation averaged scattering, it's not usually known beforehand exactly how many orientations are required to converge on the desired result. GOAD's solution to this is called a <code>Convergence</code>, which uses Westford's algorithm to track the mean and variance of one or more prescribed convergence variables. The simulation runs until the convergence criteria are met, or some maximum number of orientations is reached. A simple example runs until the standard error in the mean asymmetry parameter has an error less than 2%:</p>  Python <pre><code>from goad import Settings\nfrom goad.convergence.asymmetry import Asymmetry\nfrom goad.convergence.base import Convergence\nfrom goad.convergence.convergable import Tolerance\n\nconvergence = Convergence(\n    Settings(geom_path=\"../../../examples/data/hex.obj\", quiet=True),\n    [Asymmetry(tolerance=Tolerance.RELATIVE, threshold=0.02)],\n)\nconvergence.run()\n</code></pre> <p>which produces the following output:</p> <pre><code>\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nGOAD: [Convergence]  \u25b0\u25b1\u25b1\u25b1\u25b1\u25b1\u25b1\n\n[Orientations: 158 (max 10000)] [0.010 sec/orientation] [Minimum orientations check: \u2713]\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\nAsymmetry       0.7726 \u00b1 0.0154 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% [SEM: 2.00% / 2.00%]\n\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n</code></pre>"},{"location":"convergence/#accessing-results","title":"Accessing Results","text":"<p>A GOAD <code>Convergence</code> class uses Welford's algorithm to track the mean and variance of all scattering properties across each orientation. The example below shows how to access the mean results, and their corresponding errors:</p>  Python <pre><code>import numpy as np\nfrom goad import Settings\nfrom goad.convergence.asymmetry import Asymmetry\nfrom goad.convergence.base import Convergence\nfrom goad.convergence.convergable import Tolerance\n\nnp.set_printoptions(threshold=4)\nnp.set_printoptions(precision=3)\n\nconvergence = Convergence(\n    Settings(geom_path=\"./data/hex.obj\", quiet=True, particle_refr_index_im=0.001),\n    [Asymmetry(tolerance=Tolerance.RELATIVE, threshold=0.01)],\n)\nconvergence.run()\nresults = convergence.results()\n\n# Get the main integrated parameters\nprint(f\"Asymmetry: {results.asymmetry:.4f}\")\nprint(f\"Scattering Cross Section: {results.scat_cross:.4f}\")\nprint(f\"Extinction Cross Section: {results.ext_cross:.4f}\")\nprint(f\"Absorption Cross Section: {results.ext_cross - results.scat_cross:.4f}\")\nprint(f\"Single Scattering Albdeo: {results.albedo:.4f}\")\n\n# Access the Mueller matrix\nprint(f\"Theta bins: \\n{results.bins_1d[:]}\")\nprint(f\"[Theta, Phi] bins: \\n{results.bins[:]}\")\nprint(f\"Mueller matrix S11: {results.mueller_1d[:, 0]}\")\nprint(f\"Mueller matrix S12: {results.mueller_1d[:, 1]}\")\n</code></pre> <p>which produces the following output:</p> <pre><code>python convergence.py\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nGOAD: [Convergence]  \u25b0\u25b1\u25b1\u25b1\u25b1\u25b1\u25b1\n\n[Orientations: 576 (max 100000)] [0.018 sec/orientation] [Minimum orientations check: \u2713]\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n\nAsymmetry       0.8338 \u00b1 0.0083 \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 100% [SEM: 1.00% / 1.00%]\n\n\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\nAsymmetry: 0.8338\nScattering Cross Section: 172.7278\nExtinction Cross Section: 207.7922\nAbsorption Cross Section: 35.0644\nSingle Scattering Albdeo: 0.8313\nTheta bins:\n[[5.000e-02]\n [1.500e-01]\n [2.500e-01]\n ...\n [1.798e+02]\n [1.799e+02]\n [1.799e+02]]\n[Theta, Phi] bins:\n[[5.000e-02 3.750e+00]\n [5.000e-02 1.125e+01]\n [5.000e-02 1.875e+01]\n ...\n [1.799e+02 3.412e+02]\n [1.799e+02 3.488e+02]\n [1.799e+02 3.562e+02]]\nMueller matrix S11: [3.696e+07 3.667e+07 3.612e+07 ... 3.594e+03 3.607e+03 3.614e+03]\nMueller matrix S12: [ 17.73   -6.18  -12.768 ...   5.655   2.052   0.259]\n</code></pre> <p>It is important to note that the error here is only a best-case scenario estimate. It is the estimated error due to the Monte-Carlo orientation sampling. GOAD itself is an approximate method - the error in asymmetry parameter at size 60 is typically ~1% compared to more accurate methods like the discrete dipole approximation. For this reason, it doesn't make much sense to converge beyond a relative error of 0.1%. True error decreases with size, so you might want to converge to smaller thresholds then.</p>"},{"location":"convergence/#multiple-targets","title":"Multiple Targets","text":"<p>It is possible to set multiple targets to converge on. The convergence will then run until all targets have converged. The following example runs until 2% error in the asymmetry parameter and 2% error in the extinction cross section for a particle with a modified imaginary part of the refractive index (see the <code>Settings</code> class for full details on configuration options):</p>  Python <pre><code>from goad import Settings\nfrom goad.convergence.asymmetry import Asymmetry\nfrom goad.convergence.base import Convergence\nfrom goad.convergence.convergable import Tolerance\nfrom goad.convergence.ext_cross import ExtCross\n\nconvergence = Convergence(\n    Settings(\n        geom_path=\"path/to/geometry.obj\",\n        quiet=True,\n        particle_refr_index_im=0.001,\n    ),\n    [\n        ExtCross(tolerance=Tolerance.RELATIVE, threshold=0.02),\n        Asymmetry(tolerance=Tolerance.RELATIVE, threshold=0.02),\n    ],\n)\nconvergence.run()\n</code></pre>"},{"location":"convergence/#other-examples","title":"Other Examples","text":""},{"location":"convergence/#single-scattering-albedo","title":"Single scattering albedo:","text":"Python <pre><code>from goad import Settings\nfrom goad.convergence.albedo import Albedo\nfrom goad.convergence.base import Convergence\nfrom goad.convergence.convergable import Tolerance\n\nconvergence = Convergence(\n    Settings(\n        geom_path=\"path/to/geometry.obj\",\n        quiet=True,\n        particle_refr_index_im=0.001,\n    ),\n    [Albedo(tolerance=Tolerance.RELATIVE, threshold=0.005)],\n)\nconvergence.run()\n</code></pre> <p>Albedo is of course just equal to 1 for non-absorbing particles, so it is not a useful parameter to converge on in those cases.</p>"},{"location":"convergence/#extinction-cross-section","title":"Extinction Cross Section","text":"Python <pre><code>from goad import Settings\nfrom goad.convergence.base import Convergence\nfrom goad.convergence.convergable import Tolerance\nfrom goad.convergence.ext_cross import ExtCross\n\nconvergence = Convergence(\n    Settings(\n        geom_path=\"path/to/geometry.obj\",\n        quiet=True,\n        particle_refr_index_im=0.001,\n    ),\n    [ExtCross(tolerance=Tolerance.RELATIVE, threshold=0.02)],\n)\nconvergence.run()\n</code></pre>"},{"location":"convergence/#convergable-parameters","title":"Convergable Parameters","text":"<p>The following table lists the current convergable parameters and some recommendations for starting values:</p> Parameter Recommended Value Description <code>Asymmetry</code> <code>Relative: 0.01</code> Asymmetry parameter, the integrated cosine-weighted scattering <code>ScattCross</code> <code>Relative: 0.01</code> Scattering cross section, the integrated scattering <code>ExtCross</code> <code>Relative: 0.01</code> Extinction cross section, the integrated scattering + absorption <code>Albedo</code> <code>Relative: 0.01</code> Single scattering albedo, the ratio of scattering cross section to extinction cross section"},{"location":"results/","title":"Results","text":"<p>After solving a GOAD problem, access the scattering results through the <code>results</code> property of the <code>MultiProblem</code> object. For information about checking the validity of the results, see Checks.</p>"},{"location":"results/#basic-usage","title":"Basic Usage","text":"Python <pre><code>from goad import MultiProblem, Settings\n\n# Solve the problem and access results\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\nresults = mp.results\n</code></pre>"},{"location":"results/#mueller-matrices","title":"Mueller Matrices","text":"<p>The Mueller matrix describes the transformation of the Stokes vector during scattering. GOAD provides Mueller matrices in different forms and for different scattering components.</p>"},{"location":"results/#2d-mueller-matrix","title":"2D Mueller Matrix","text":"<p>Full angular distribution over theta and phi:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\n# Get the 2D Mueller matrix\nmueller = mp.results.mueller\nprint(f\"Number of bins: {len(mueller)}\")\nprint(f\"Mueller matrix elements per bin: {len(mueller[0])}\")  # 16 elements\n</code></pre> <p>The Mueller matrix is returned as a list of 16-element lists, where each element corresponds to <code>[s11, s12, s13, s14, s21, s22, s23, s24, s31, s32, s33, s34, s41, s42, s43, s44]</code> for each bin.</p>"},{"location":"results/#1d-mueller-matrix","title":"1D Mueller Matrix","text":"<p>Phi-integrated Mueller matrix (theta only):</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\n# Get the 1D phi-integrated Mueller matrix\nmueller_1d = mp.results.mueller_1d\nprint(f\"Number of theta bins: {len(mueller_1d)}\")\n</code></pre> <p>The 1D Mueller matrix integrates over all phi angles at each theta, providing an azimuthally-averaged scattering pattern.</p>"},{"location":"results/#mueller-matrix-components","title":"Mueller Matrix Components","text":"<p>GOAD separates scattering into beam and external diffraction components:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\n# Access different scattering components\nmueller_total = mp.results.mueller  # Total scattering\nmueller_beam = mp.results.mueller_beam  # Beam component\nmueller_ext = mp.results.mueller_ext  # External diffraction\n\n# Same for 1D Mueller matrices\nmueller_1d_total = mp.results.mueller_1d\nmueller_1d_beam = mp.results.mueller_1d_beam\nmueller_1d_ext = mp.results.mueller_1d_ext\n</code></pre> <ul> <li>Beam component: Direct scattering from ray tracing</li> <li>External diffraction: Diffraction around the particle exterior</li> <li>Total: Sum of beam and external diffraction components. If coherence is disabled, the total is just the linear sum of beam and external diffraction components.</li> </ul>"},{"location":"results/#angular-bins","title":"Angular Bins","text":"<p>Access the angular coordinates for each bin:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\n# Get 2D bins (theta, phi pairs)\nbins_2d = mp.results.bins\nfor theta, phi in bins_2d[:5]:  # First 5 bins\n    print(f\"Theta: {theta}\u00b0, Phi: {phi}\u00b0\")\n\n# Get 1D bins (theta only)\nbins_1d = mp.results.bins_1d\nif bins_1d:\n    print(f\"Theta values: {bins_1d}\")\n</code></pre> <p>The bins correspond to the center values of each angular bin in the scattering calculation. It is also possible to directly access the theta and phi values from the binning scheme, which is useful if you need to access the bins without running the simulation.</p>"},{"location":"results/#integrated-parameters","title":"Integrated Parameters","text":"<p>GOAD computes several integrated optical parameters from the Mueller matrix if the binning scheme is <code>simple</code> or <code>interval</code>.</p>"},{"location":"results/#scattering-cross-section","title":"Scattering Cross Section","text":"<p>The total scattering cross section:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\nscat_cross = mp.results.scat_cross\nprint(f\"Scattering cross section: {scat_cross}\")\n</code></pre>"},{"location":"results/#extinction-cross-section","title":"Extinction Cross Section","text":"<p>The total extinction cross section (scattering + absorption):</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\next_cross = mp.results.ext_cross\nprint(f\"Extinction cross section: {ext_cross}\")\n</code></pre>"},{"location":"results/#asymmetry-parameter","title":"Asymmetry Parameter","text":"<p>The asymmetry parameter <code>g</code> (average cosine of scattering angle):</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\ng = mp.results.asymmetry\nprint(f\"Asymmetry parameter: {g}\")\n</code></pre> <p>Values range from -1 (complete backscattering) to +1 (complete forward scattering).</p>"},{"location":"results/#single-scattering-albedo","title":"Single Scattering Albedo","text":"<p>The ratio of scattering to extinction:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\nalbedo = mp.results.albedo\nprint(f\"Single scattering albedo: {albedo}\")\n</code></pre> <p>Values range from 0 (pure absorption) to 1 (pure scattering).</p>"},{"location":"results/#power-budget","title":"Power Budget","text":"<p>Track energy conservation throughout the simulation:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\nmp = MultiProblem(Settings(geom_path=\"path/to/geometry.obj\"))\nmp.solve()\n\npowers = mp.results.powers\nprint(f\"Input power: {powers['input']}\")\nprint(f\"Output power: {powers['output']}\")\nprint(f\"Absorbed power: {powers['absorbed']}\")\nprint(f\"Missing power: {powers['missing']}\")\n\n# Check energy conservation\ntotal_accounted = (\n    powers[\"output\"]\n    + powers[\"absorbed\"]\n    + powers[\"trnc_ref\"]\n    + powers[\"trnc_rec\"]\n    + powers[\"trnc_clip\"]\n    + powers[\"trnc_energy\"]\n    + powers[\"trnc_area\"]\n)\nprint(f\"Energy conservation error: {powers['input'] - total_accounted}\")\n</code></pre> <p>The power dictionary contains:</p> <ul> <li><code>input</code>: Incident beam power</li> <li><code>output</code>: Total scattered power</li> <li><code>absorbed</code>: Power absorbed by the particle</li> <li><code>trnc_ref</code>: Power lost to reflection truncation</li> <li><code>trnc_rec</code>: Power lost to recursion limit</li> <li><code>trnc_clip</code>: Power lost to clipping</li> <li><code>trnc_energy</code>: Power lost to energy cutoff</li> <li><code>trnc_area</code>: Power lost to area threshold</li> <li><code>trnc_cop</code>: Power lost to coplanar threshold</li> <li><code>clip_err</code>: Error from clipping algorithm</li> <li><code>ext_diff</code>: External diffraction power</li> <li><code>missing</code>: Total unaccounted power</li> </ul>"},{"location":"results/#complete-example","title":"Complete Example","text":"Python <pre><code>import numpy as np\nfrom goad import BinningScheme, MultiProblem, Orientation, Settings\n\n# Configure and solve\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    wavelength=0.532,\n    orientation=Orientation.uniform(num_orients=100),\n    binning=BinningScheme.simple(num_theta=180, num_phi=48),\n)\nmp = MultiProblem(settings)\nmp.solve()\n\n# Access all results\nresults = mp.results\n\n# Extract scattering phase function (S11 element)\nmueller_1d = np.array(results.mueller_1d)\ns11 = mueller_1d[:, 0]  # First column is S11\ntheta = np.array(results.bins_1d)\n\n# Print integrated parameters\nprint(f\"Scattering cross section: {results.scat_cross:.6f}\")\nprint(f\"Extinction cross section: {results.ext_cross:.6f}\")\nprint(f\"Asymmetry parameter: {results.asymmetry:.4f}\")\nprint(f\"Single scattering albedo: {results.albedo:.4f}\")\n\n# Check power budget\npowers = results.powers\nefficiency = powers[\"output\"] / powers[\"input\"]\nprint(f\"Scattering efficiency: {efficiency:.4f}\")\nprint(f\"Missing power fraction: {powers['missing'] / powers['input']:.2e}\")\n</code></pre>"},{"location":"results/#result-properties-reference","title":"Result Properties Reference","text":"Property Type Description <code>bins</code> <code>list[list[float]]</code> 2D angular bins <code>[[theta, phi], ...]</code> <code>bins_1d</code> <code>list[float] \\| None</code> 1D theta bins <code>mueller</code> <code>list[list[float]]</code> 2D Mueller matrix (total) <code>mueller_beam</code> <code>list[list[float]]</code> 2D Mueller matrix (beam component) <code>mueller_ext</code> <code>list[list[float]]</code> 2D Mueller matrix (external diffraction) <code>mueller_1d</code> <code>list[list[float]]</code> 1D Mueller matrix (total) <code>mueller_1d_beam</code> <code>list[list[float]]</code> 1D Mueller matrix (beam component) <code>mueller_1d_ext</code> <code>list[list[float]]</code> 1D Mueller matrix (external diffraction) <code>scat_cross</code> <code>float \\| None</code> Scattering cross section <code>ext_cross</code> <code>float \\| None</code> Extinction cross section <code>asymmetry</code> <code>float \\| None</code> Asymmetry parameter g <code>albedo</code> <code>float \\| None</code> Single scattering albedo <code>powers</code> <code>dict[str, float]</code> Power budget dictionary"},{"location":"settings/","title":"Settings","text":"<p>The <code>Settings</code> object configures a GOAD simulation. It controls physical parameters, numerical methods, and output options.</p>"},{"location":"settings/#basic-usage","title":"Basic Usage","text":"<p>At minimum, you must specify the path to a geometry file:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\n# Basic settings with minimal configuration\nsettings = Settings(geom_path=\"path/to/geometry.obj\")\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>The geometry defines the units of the problem. If your geometry file is in microns, then you should also specify the wavelength in microns. All faces in the geometry must be planar and have some non-zero area. GOAD will return with an error if there are faces with zero area (ie. extremely thin triangles), since it needs to compute normals of each face by a cross product of 2 non-colinear edge vectors. You can make geometries in the open-source Blender software, or use some example geometries straight from Python here.</p>"},{"location":"settings/#physical-parameters","title":"Physical Parameters","text":""},{"location":"settings/#wavelength","title":"Wavelength","text":"<p>The wavelength of incident light in micrometers:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\n# Configure wavelength (in micrometers)\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    wavelength=0.532,  # 532 nm\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Default: <code>0.532</code> (532 nm, green laser)</p>"},{"location":"settings/#refractive-indices","title":"Refractive Indices","text":"<p>Specify the complex refractive index for both the particle and surrounding medium:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\n# Configure refractive indices for particle and medium\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    particle_refr_index_re=1.5,  # Real part of particle refractive index\n    particle_refr_index_im=0.01,  # Imaginary part (absorption)\n    medium_refr_index_re=1.33,  # Water as medium\n    medium_refr_index_im=0.0,\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Defaults:</p> <ul> <li><code>particle_refr_index_re</code>: <code>1.31</code> (typical glass)</li> <li><code>particle_refr_index_im</code>: <code>0.0</code></li> <li><code>medium_refr_index_re</code>: <code>1.0</code> (vacuum/air)</li> <li><code>medium_refr_index_im</code>: <code>0.0</code></li> </ul>"},{"location":"settings/#particle-scaling","title":"Particle Scaling","text":"<p>Scales the entire problem, including geometry and wavelength. Does not change the physics, only used for improving clipping algorithm accuracy. The default value is usually sufficient.</p> <p>Parameter: <code>scale</code> Default: <code>1.0</code></p>"},{"location":"settings/#orientation-distribution","title":"Orientation Distribution","text":"<p>Define how particle orientations are sampled:</p>  Python <pre><code>from goad import EulerConvention, MultiProblem, Orientation, Settings\n\n# Configure particle orientation distribution\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    orientation=Orientation.uniform(\n        num_orients=100, euler_convention=EulerConvention(\"ZYZ\")\n    ),\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Default: <code>Orientation.uniform(num_orients=1)</code> with <code>EulerConvention('ZYZ')</code></p> <p>For discrete orientations:</p>  Python <pre><code>from goad import Euler, EulerConvention, MultiProblem, Orientation, Settings\n\n# Configure discrete orientations\norients = Orientation.discrete(\n    eulers=[Euler(0, 0, 0), Euler(45, 90, 0)], euler_convention=EulerConvention(\"ZYZ\")\n)\nsettings = Settings(geom_path=\"path/to/geometry.obj\", orientation=orients)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>The output will be an average over the orientations. Results from individual orientations are not stored. See Results for more details.</p>"},{"location":"settings/#seed","title":"Seed","text":"<p>Seeds the random number generator for reproducibility.</p> <p>Parameter: <code>seed</code> Default: <code>None</code></p>"},{"location":"settings/#angular-binning","title":"Angular Binning","text":"<p>Control the angular resolution of scattering calculation in the far-field. As particle size increases, the width of peaks in the scattering decreases. GOAD currently requires the user to choose a sufficiently fine binning scheme to resolve the peaks. For <code>phi</code> angles, a relatively course binning scheme can be used, but for <code>theta</code> angles, care should be taken to ensure sufficient resolution, otherwise the integrated parameters lose accuracy. The compute time approximately scales with the number of bins, which for <code>simple</code> and <code>interval</code> binning schemes is just the product of the number of bins in each dimension.</p>"},{"location":"settings/#simple-binning","title":"Simple Binning","text":"<p>Uniform spacing in theta and phi:</p>  Python <pre><code>from goad import BinningScheme, MultiProblem, Settings\n\n# Configure angular binning for scattering output\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    binning=BinningScheme.simple(num_theta=180, num_phi=360),\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Default: <code>BinningScheme.interval(thetas=[0, 5, 175, 179, 180], theta_spacings=[0.1, 2.0, 0.5, 0.1], phis=[0, 360], phi_spacings=[7.5])</code></p>"},{"location":"settings/#interval-binning","title":"Interval Binning","text":"<p>Variable resolution for different angular regions:</p>  Python <pre><code>from goad import BinningScheme, MultiProblem, Settings\n\n# Use variable angular resolution\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    binning=BinningScheme.interval(\n        thetas=[0, 90, 180],\n        theta_spacings=[1, 2],  # 1\u00b0 steps up to 90\u00b0, then 2\u00b0 steps\n        phis=[0, 360],\n        phi_spacings=[2],\n    ),\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>This example uses 1\u00b0 resolution for forward scattering (0-90\u00b0) and 2\u00b0 for backward scattering (90-180\u00b0). <code>interval</code> binning schemes are useful if the user is only interested in a specific angular scattering range, eg 6\u00b0-25\u00b0.</p>"},{"location":"settings/#custom-binning","title":"Custom Binning","text":"<p>Specify arbitrary bin edges:</p>  Python <pre><code>from goad import BinningScheme, MultiProblem, Settings\n\n# Specify arbitrary bin edges\nbinning = BinningScheme.custom(\n    bins=[\n        [[0, 10], [0, 360]],  # Forward scattering cone\n        [[10, 170], [0, 360]],  # Side scattering\n        [[170, 180], [0, 360]],  # Backscattering cone\n    ]\n)\nsettings = Settings(geom_path=\"path/to/geometry.obj\", binning=binning)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>GOAD will compute the bin centres automatically. GOAD will not compute the 1D mueller matrix or integrated parameters if using a <code>custom</code> binning scheme.</p>"},{"location":"settings/#mapping-method","title":"Mapping Method","text":"<p>Choose how near-field results map to the far-field:</p>  Python <pre><code>from goad import Mapping, MultiProblem, Settings\n\n# Configure near-to-far field mapping method\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    mapping=Mapping(\"ad\"),  # 'ad' for Aperture Diffraction, 'go' for Geometric Optics\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Options:</p> <ul> <li><code>'ad'</code>: Aperture Diffraction (default, more accurate). Suitable for fixed-orientation computations.</li> <li><code>'go'</code>: Geometric Optics (faster, suitable for very large particles). Generally not suitable for fixed-orientation computations.</li> </ul> <p>Default: <code>Mapping('ad')</code></p>"},{"location":"settings/#beam-tracing-parameters","title":"Beam Tracing Parameters","text":"<p>Beams traced in the near-field if they pass the following checks, in order:</p> <ul> <li>Beam power is below the threshold</li> <li>Beam area is below the threshold</li> <li>Beam number of recursion is above the threshold</li> </ul> <p>If the beam is from a total internal reflection event, the beam is traced even if the recursion is above the threshold, as long as the total internal reflection count is below the threshold.</p>"},{"location":"settings/#beam-thresholds","title":"Beam Thresholds","text":"<p>Control when beams are truncated during ray tracing:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\n# Configure beam tracing thresholds\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    beam_power_threshold=1e-6,  # Stop tracking beams below this power\n    beam_area_threshold_fac=1e-3,  # Stop tracking beams smaller than this fraction\n    cutoff=1e-10,  # Global energy cutoff\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Defaults:</p> <ul> <li><code>beam_power_threshold</code>: <code>0.005</code> (discard beams below 0.5% of incident power).</li> <li><code>beam_area_threshold_fac</code>: <code>0.1</code> (factor \u00d7 \u03bb\u00b2 determines the physical area threshold, below which beams are discarded. It scales with \u03bb\u00b2 following the applicability of geometric optics).</li> <li><code>cutoff</code>: <code>0.99</code> (trace 99% of energy in the near field, then map. You generally want to use a value of at least 0.95 here, unless you have a good reason to do otherwise).</li> </ul> <p>Lower thresholds and higher cutoff increases accuracy but slows computation.</p>"},{"location":"settings/#recursion-limits","title":"Recursion Limits","text":"<p>Limit internal beams bounces:</p>  Python <pre><code>from goad import MultiProblem, Settings\n\n# Configure ray tracing limits\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    max_rec=10,  # Maximum internal reflections\n    max_tir=5,  # Maximum total internal reflections\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre> <p>Defaults:</p> <ul> <li><code>max_rec</code>: <code>10</code> (maximum internal reflections)</li> <li><code>max_tir</code>: <code>10</code> (maximum total internal reflections)</li> </ul> <p>Increase these for complex internal ray paths, but expect slower performance. High numbers of total internal reflections recommended for backscattering computations, ie. <code>20</code>.</p>"},{"location":"settings/#output-options","title":"Output Options","text":""},{"location":"settings/#directory","title":"Directory","text":"<p>Specify output directory for simulation data:</p> <p>Parameter: <code>directory</code> Default: <code>\"goad-run\"</code> </p>"},{"location":"settings/#coherence","title":"Coherence","text":"<p>Enable coherent beam addition (phase tracking):</p> <p>Parameter: <code>coherence</code> Default: <code>True</code></p> <p>Enables coherent beam addition with phase tracking for interference effects. If coherence is enabled, GOAD traces the phase of each beam, and combines amplitude matrices in the far-field with interference. If coherence is disabled, GOAD traces the phase of each beam, but combines the far-field contributions of beams in the far-field only by a linear summation of Mueller matrices. Coherence should be enabled for backscattering computations.</p>"},{"location":"settings/#verbosity","title":"Verbosity","text":"<p>Suppress console output:</p> <p>Parameter: <code>quiet</code> Default: <code>False</code></p> <p>Set to <code>True</code> to silence progress messages.</p>"},{"location":"settings/#complete-example","title":"Complete Example","text":"Python <pre><code>from goad import BinningScheme, Mapping, MultiProblem, Orientation, Settings\n\n# Complete configuration example\nsettings = Settings(\n    geom_path=\"path/to/geometry.obj\",\n    wavelength=0.532,\n    particle_refr_index_re=1.5,\n    particle_refr_index_im=0.01,\n    medium_refr_index_re=1.0,\n    medium_refr_index_im=0.0,\n    orientation=Orientation.uniform(num_orients=100),\n    binning=BinningScheme.simple(num_theta=180, num_phi=360),\n    mapping=Mapping(\"ad\"),\n    beam_power_threshold=1e-6,\n    beam_area_threshold_fac=1e-3,\n    cutoff=0.999,\n    max_rec=10,\n    max_tir=5,\n    coherence=False,\n    quiet=False,\n    directory=\"output/\",\n)\nmp = MultiProblem(settings)\nmp.solve()\n</code></pre>"},{"location":"settings/#parameter-reference","title":"Parameter Reference","text":"Parameter Type Default Description <code>geom_path</code> <code>str</code> Required Path to geometry file <code>wavelength</code> <code>float</code> <code>0.532</code> Wavelength in geometry units <code>particle_refr_index_re</code> <code>float</code> <code>1.31</code> Real part of particle refractive index <code>particle_refr_index_im</code> <code>float</code> <code>0.0</code> Imaginary part of particle refractive index <code>medium_refr_index_re</code> <code>float</code> <code>1.0</code> Real part of medium refractive index <code>medium_refr_index_im</code> <code>float</code> <code>0.0</code> Imaginary part of medium refractive index <code>orientation</code> <code>Orientation</code> <code>Orientation.uniform(1)</code> Orientation distribution <code>binning</code> <code>BinningScheme</code> <code>interval(...)</code> Angular binning scheme (high-res forward/back) <code>mapping</code> <code>Mapping</code> <code>Mapping('ad')</code> Near-to-far field mapping method <code>beam_power_threshold</code> <code>float</code> <code>0.005</code> Beam power truncation threshold <code>beam_area_threshold_fac</code> <code>float</code> <code>0.1</code> Beam area truncation factor <code>cutoff</code> <code>float</code> <code>0.99</code> Energy tracking cutoff <code>max_rec</code> <code>int</code> <code>10</code> Maximum internal reflections <code>max_tir</code> <code>int</code> <code>10</code> Maximum total internal reflections <code>scale</code> <code>float</code> <code>1.0</code> Geometry scaling factor <code>seed</code> <code>int</code> <code>None</code> Seed for random number generator <code>directory</code> <code>str</code> <code>\"goad_run\"</code> Output directory path <code>coherence</code> <code>bool</code> <code>True</code> Enable coherent beam addition <code>quiet</code> <code>bool</code> <code>False</code> Suppress console output"}]}